###Стоит читать это в таком порядке:
* input.py
* arithmetic.py (его пока нет, но это временно)
* strings.py
* lists.py
* slices.py
* python-tutorial.py


#Программирование
В программах есть *переменные*, в которых хранится то, что нужно программисту, и операции,
преобразовывающие существующие переменные. Результаты выполнения операций можно записывать в новые
переменные. Стоит называть переменные понятным английским языком (не транслитом и не `qwerty`),
чтобы через неделю (месяц, год) вы всё ещё понимали, что именно лежит в этой переменной.

##Форматирование
Также, стоит писать код с правильным форматированием, так он будет выглядеть красивее, читаемее,
приятнее. Основные правила - 
+ Если пробел по какой-то причине нужно ставить, а по другой не нужно, то пробел ставится. Если по
  двум правилам надо ставить пробел, ставить нужно один пробел, а не два.
+ Операции с одним аргументом (например, `-a` - отрицание числа) не обособляются пробелами.
+ Операции с двумя аргументами (например, `a + b` - сумма чисел, `a = b` - присваивание)
  обособляются пробелами.
+ Скобки
 + Вокруг скобок, изнутри и снаружи, пробелы не ставятся. Например, `input()`, `(a + b) * c`
+ Знаки препинания:
 + Вокруг `.` не ставятся пробелы
 + Пробелы ставятся после запятой, а до запятой не ставятся `print(a, b)`

#Простейшие операции
С уже существующими переменными можно делать всё, что угодно - выводить, передавать в функцию. 
Но есть некоторые основные операции:
* `a = b` - **присваивание** к переменной a. Вместо `b` может быть не только переменная, но и
  выражение, например, сумма, или результат функций. А слева от оператора присваивания (название для одиночного `=`)
* `a + b` - то самое выражение из пред. строки. Результат можно присвоить в новую или уже существующую переменную. (Здесь вместо как `a`, так и `b` могут стоять другие выражения)
* `a += b` - Это ещё один вид присваивания. Он значит то же, что и `a = a + b`, но так длинно.
* `a == b, a != b, a < b, a <= b` - операторы сравнения. По порядку - верно, если `a` и `b` совпадают. Второе - "не равно", обратное первому. Третье - "а меньше b", четвёртое - "a <= b"
Новые переменные создаются, когда вы используете присваивание к ним. Если вам нужно просто создать переменную, присвойте ей 0 (если число), или "", если строку. Про строки можно прочесть в `strings.py`

##Ввод данных
Очень часто надо считывать то, что вводит пользователь с клавиатуры.
Самый простой способ это делать - функция `input()`. Она возвращает *строку* в привычном нам
понимании.
Считанные символы до перевода строки. Если мы хотим преобразовать *строку* `s` в число, то следует
написать `int(s)` - преобразуем в целое число, или `float(s)` - в десятичную дробь. Если *строка*
содержит недопустимые символы (строку *qwerty* сложно преобразовать в число), то программа "упадёт",
то есть, завершится с ошибкой.

##Функции
Выше есть примеры нескольких функций, которые делают разные вещи, но они все функции. 
**Функция** - объект, который можно *вызвать*. В математике они тоже называются функциями, например, `f(x)` или `sin(x)`
У функции есть имя (синус), список параметров (`x`), и возвращаемое значение - то, зачем мы, собственно, зовём функцию. Из примеров выше есть функция `input`, которой можно совсем не передавать параметров, и возвращает она строку. Также есть функция `print`, которой можно передавать сколько угодно параметров, и она выведет их на экран. Можно сказать, что и `int(s)`, и `float(s)` являются функциями, которые принимают параметр - строку и возвращают число.

По сути, функция - некая машинка, которой можно скормить значения, и она тебе вернёт результат.

Каждый параметр функции тоже является выражением, не обязательно переменной.
##Арифметические операции
Что мы можем делать с числами?
* Складывать, вычитать, умножать, делить - `a + b, a - b, a * b, a / b`
* Сравнивать - `a < b, a <= b, a >= b, a > b ` - меньше, меньше либо равно, больше либо равно,
  больше
* `a == b, a != b` - равно, не равно
* Делить нацело (неполное частное и остаток) - `a // b, a % b`
* Возводить в степень - `a ** b` - а в степени b. Также есть функция `pow(a, b)`, которая делает то
  же самое.
Для каждой из этих операций есть соответствующее присваивание - `a + b` --- `a += b`. Присваивание
`a @= b`, где @ - какая-то операция, значит ровно `a = a @ b`. Вместо @ может быть `+, -, ..., **, //`.

#Условные инструкции
Возможно, вы хотите, чтобы ваша программа работала по-разному в зависимости от входных данных.
Например, вы хотите вывести модуль числа из входа. Синтаксис следующий:

```python3
a = 5
b = 6
if a == 3:
    print("a is 3")
elif a == 4 and b != 5:
    print("a is 4")
elif a == 5 or b == 5:
    print("a is 5")
else:
    print("nevermind")
```
Мы видим здесь несколько ключевых слов - `if, elif, else, or, and`. По порядку:
* `if` - если. После него в той же строке нужно написать некоторое условие (в примере это `a == 3`).
  Эту строку нужно закончить на двоеточие. Обязательно.
* `elif` - для него верно всё то, что верно для `if`. Но ещё он обязательно идёт после `if`.
  Расшифровывается он как `else if` - "иначе если". Говоря нормальным языком, это условие надо
  проверить в том случае, если первое неверно. А если первое верно, то не проверять. 
* `else` - завершает блок условной инструкции. То, что "принадлежит" этому `else`, выполняется, если
  все предыдущие условия не выполнились. Ему не требуются условия, но двоеточие необходимо.

Если вы пишете условную инструкцию, и не хотите никаких "иначе", то есть вы просто хотите что-то
сделать, если выполнено ваше условие, то вы можете - строки с `elif` и `else` опциональны. Может
быть только единственный `if`, может после него быть написано сколько-то (или 0) `elif`-ов, и после
всего этого написано 1 или 0 строк с `else`. Важно, что `if` должен быть один (Если в другом месте
будет `if`, то `python` подумает, что это начало новой УИ). И `else` только один.

Есть ещё ключевые слова:
* `and` - логическое И. Условие `A and B` верно тогда и только тогда, когда выполнены оба условия,
  `A` и `B`. Причём важен порядок записи - сначала проверится А, и если оно неверно, то В
  проверяться не будет.
* `or` - логическое ИЛИ. Условие `A or B` выполнено тогда и только тогда, когда хотя бы одно
  выполнено. Тут тоже порядок играет роль.
* `not` - отрицание. `not A` верно, если А неверно.

###Лирическое отступление
В некотором смысле это похоже на следующую ситуацию - Вы находитесь в комнате, а там несколько
сундуков. Вам сказали, что деньги только в одном. Ну вы открываете их по очереди, пока не найдёте
деньги. Вы проверяете, --условие `if`-- есть ли деньги в первом. Если есть, вы останавливаетесь. Иначе проверяете 
--первый `elif`-- второй сундук. Ну вы поняли.


##Блоки кода
В большинстве языков в каких-то случаях нужно объединять последовательность строк в блок, чтобы он
целиком принадлежал некотому объекту, в нашем случае, `if`-у. Можно увидеть в примере отступы. Это и
есть блоки. То есть, `if` действует очень просто - он смотрит на блок кода, начинающийся в следующей
строке, и выполняет строки, пока блок не кончится. **Важно!** `elif` и `else` должны следовать сразу
после блоков кода от предыдущих условий. Блоки могут быть вложены, например,
```python3
if a == 3:
    if b == 3:
        print("a and b are equal to 3")
    else:
        print("a is not equal to b")
...
```

##Форматирование кода в Условных Инструкциях
* Перед двоеточием, которое есть в конце каждого условия, не ставить пробелов.
* После окончания условной инструкции (то есть, после последнего условия), стоит оставить пустую
  строку
* Отступ у блока должен быть ровно 4 пробела от того места, где он написан (то есть, если мы хотим
  блок, когда у нас уже второй уровень вложенности (мы в двух `if`ах находимся, проще говоря. Вот у
  `print` из пред. примера второй уровень вложенности), то надо добавить ещё 4 пробела, итого 12).
  Во всех хороших средах разработки клавиша Tab ставит отступы, какие вам надо, попробуйте!

## Циклы
В языке *python3* есть несколько конструкций для циклов.

Вот самая простая:
```python
sum = 0
for i in range(n):
    sum += i

print(sum)
```
Несколько строк кода выше считают сумму чисел от 0 до `n` не включительно. **Важно!** Если параметр
всего один, то считается, что начинать надо от 0, а не от 1, как мы привыкли.

Есть такая вариация конструкции
```python
sum = 0
for i in range(begin, end):
    sum += i

print(sum)
```
В этих строках строках считается сумма чисел в полуинтервале `[begin, end)`, то есть, включая число
`begin`, и не включается `end`.

Идея с полуинтервалами довольно удобна, к ней надо просто немного привыкнуть. Одно из удобств: `[a,
b) + [b, c) = [a, c)`. То есть, мы складываем два граничащих полуинтервала и получаем вновь
полуинтервал. И наоборот, полуинтервал можно просто разделить на два посередине.

И последний вариант - 
```python
sum = 0
for i in range(begin, end, 2):
    sum += i

print(sum)
```
В этой вариации `i` изменяется в такой последовательности: `begin, begin + 2, begin + 4, ... `, до
тех пор, пока `i < end`. Как только `i >= end`, цикл прекращает работу.

Последний параметр может быть любым целым, например, отрицательным - это хороший способ перебирать
что-то в порядке от большего к меньшему.

