<p><meta charset="utf-8"></p>

<h1>Предисловие</h1>

<p><strong>Vim</strong> - очень мощный редактор, даже без использования плагинов. 
Я смогу рассказать далеко не всё, иначе никто не дочитает это до конца.</p>

<hr />

<h2>.vimrc</h2>

<p><em>Мооожно</em>, конечно, совсем не настраивать <strong>vim</strong>, но я не советую
таким заниматься.</p>

<h3>Что делает .vimrc</h3>

<p>Это просто набор команд, которые выполняются при каждом запуске <strong>Vim</strong><br>
Их можно исполнять и в процессе редактирования, так: </p>

<p><strong><code>: command</code></strong></p>

<h3>Что можно делать</h3>

<ul>
<li><p>Опции, которые можно включать-выключать<br>
Эти опции пишем после ключевого слова <code>set</code></p>

<ul>
<li><p><code>tabstop=N</code> - делает ширину отступа
            (который появляется при нажатии <code>tab</code>), равным N</p></li>
<li><p><code>shiftwidth=N</code> - делает величину сдвига (о них я позже расскажу)
               равной N</p></li>
<li><p><code>expandtab</code> - заменяет табы пробелами (Если таб уже где-нибудь стоит, его не трогает)</p></li>
<li><p><code>nu</code> - от слова <em>number</em> - показывает номера строк</p></li>
<li><p><code>autoindent</code>, <code>smartindent</code> - 
        две разных схемы расстановки отступов при переносах строк.
        Попробуйте обе, выберите, какая больше нравится</p></li>
<li><p><code>smarttab</code> - убирает весь отступ при нажатии backspace, если вы стираете отступ</p></li>
<li><p><code>hlsearch</code> - подсвечивает все вхождения того, что вы ищете</p></li>
<li><p><code>colorcolumn=N</code> - Рисует красный фон у каждого символа, который N-тый по счёту в своей строке
Используется, как ограничитель (писать строчку дальше - некрасиво, перейди на другую)</p></li>
<li><p><code>wrap</code> - Включает автоматические переносы (интересная штука)</p></li>
<li><p><code>wrapmargin=N</code> - делает перенос (тот, про который предыдущая команда)
    Если до конца строки осталось меньше N символов. Стоит попробовать, чтобы понять</p></li>
<li><p><code>laststatus=2</code> - включает вам строку состояния</p></li>
<li><p><code>statusline=String</code> - настраивает строку состояния из пред. команды
Наберите <strong><code>:help statusline</code></strong>, чтобы прочитать про это больше.
<br>Для неё можно поставить некоторые плагины, например, powerline.</p></li>
</ul></li>
<li><p>сочетания клавиш</p>

<p>В <strong>vim</strong> можно поставить на любое сочетание клавиш что угодно</p>

<p>Любую команду или последовательность команд, которую можно выполнить в <strong>vim</strong></p>

<p>Для этого надо писать так:<br>
<em><code>[niv]map сочетание команда</code></em><br> ([abc] - a, b или с, я часто буду так писать)
Записывая сочетания, всё, кроме пробела, пишем как есть</p>

<p>Эта первая буква показывает, в каком режиме вы хотите использовать сочетание</p>

<ul>
<li><code>n - Normal</code></li>
<li><code>i - Insert</code></li>
<li><code>v - Visual</code></li>
</ul>

<p>Пробел, Ctrl, Shift, Tab, F1-F12 = <code>&lt;Space&gt;, &lt;C&gt;, &lt;S&gt;, &lt;Tab&gt;, &lt;F1&gt; .. &lt;F12&gt;</code></p>

<p>Много модификаторов пишем в одних <code>&lt;&gt;</code></p>

<p><p>Например, 
<code>&lt;C-S-F6&gt;</code> </p></li>
</ul>
<hr /></p>

<h2>Редактор</h2>

<h3>movement</h3>

<ul>
<li><p><strong>General</strong></p>

<ul>
<li><p><code>hjkl</code> - двигаетесь влево, вниз, вверх, вправо соотв.</p></li>
<li><p><code>web</code> - двигаетесь в начало следующего слова, в конец следующего, в начало предыдущего соотв.</p>

<p>Cлова - последовательности букв, цифр и _</p></li>
<li><p><code>WEB</code> - То же, только для больших слов.
    Большие слова разделены пробелами и переносами строк, остальное - часть большого слова</p></li>
</ul></li>
<li><p><strong>scrolling</strong></p>

<ul>
<li><p><code>gg, [[</code> - начало файла</p></li>
<li><p><code>G, ]]</code> - конец файла</p></li>
<li><p><code>HML</code> - перемещает курсор в верх, в центр и в низ экрана соотв.</p></li>
<li><p><code>Ctrl-b, Ctrl-u</code> = Page Up, Page Down</p></li>
</ul></li>
<li><p><strong>in line</strong></p>

<ul>
<li><p><code>f&lt;symbol&gt;</code> -- Находит следующее после курсора вхождение символа в строке, где курсор</p></li>
<li><p><code>F&lt;symbol&gt;</code> -- Находит предыдущее ...</p></li>
<li><p><code>;</code>     -- Повторяет последнее действие такого поиска, ищет в ту же сторону.</p></li>
<li><p><code>,</code>     -- Ищет в другую сторону.</p></li>
<li><p><code>0</code>     -- Начало строки</p></li>
<li><p><code>$</code>     -- Конец строки</p></li>
<li><p><code>^</code>     -- Первый непробельный символ</p></li>
</ul></li>
<li><p><strong>useful</strong></p>

<ul>
<li><p><code>%</code> -- Переходит к парной скобке</p></li>
<li><p>`[(' -- Переходит к открывающей скобке из той пары, внутри которой вы находитесь.</p></li>
<li><p><code>[)</code> -- К закрывающей</p>

<p>Аналогично, <code>[{</code></p></li>
<li><p><code>{</code> -- Предыдущая пустая строка. Если вы действительно расставляете пустые строки
чтобы показать логику работы, это полезно.</p></li>
<li><p><code>}</code> -- Cледующая пустая строка.</p></li>
<li><p><code>&lt;N&gt;G</code> -- переходит на строку №<N></p></li>
<li><p><code>gi</code> -- Идёт туда, где вы вышли из Insert mode и переходит в него</p></li>
<li><p><code>gd</code> -- Идёт к объявлению переменной</p></li>
</ul></li>
</ul>

<p>Эти все сочетания работают как в Normal mode, так и в Visual, и это удобно</p>

<hr />

<h2>Важно!</h2>

<p><code>&lt;N&gt;&lt;movement&gt;</code> - Повторить movement N раз
<code>&lt;N&gt;&lt;command&gt;</code> - повторить команду N раз</p>

<hr />

<h3>Editing</h3>

<ul>
<li>from Normal mode to Insert
<ul>
<li><code>i</code> -- Просто перейти</li>
<li><code>a</code> -- Сдвинуться вправо на один символ и перейти (Полезно, т.к. Escape сдвигает влево)</li>
<li><code>I</code> -- Пойти в начало строки и перейти</li>
<li><code>A</code> -- Пойти в конец строки и перейти</li>
<li><code>o</code> -- Вставить пустую строку после текущей, пойти туда и перейти (отступы работают)</li>
<li><code>O</code> -- Вставить ... ДО текущей ...</li>
<li><code>сс</code> -- очистить эту строку (останется пустая строка) и перейти</li>
<li><code>С</code> -- удалить всё до конца строки и перейти</li>
<li><code>с&lt;movement&gt;</code> -- удалить отрезок с концами (где был курсор, где сейчас курсор)
и перейти</li>
<li><code>s</code> -- удалить символ и перейти</li>
<li><code>S</code> -- То же, что и cc</li>
</ul></li>
<li>other
<ul>
<li><code>dd</code> -- Удалить текущую строку</li>
<li><code>d&lt;movement&gt;</code> -- удалить отрезок...</li>
<li><code>D</code> --  Удалить до конца строки</li>
<li><code>&gt;&gt;</code> -- Добавить слева shiftwidth пробелов</li>
<li><code>&lt;&lt;</code> -- Убрать слева max(shiftwidth, сколько есть) пробелов</li>
<li><code>yy</code> -- Скопировать текущую строку</li>
<li><code>y&lt;movement&gt;</code> -- скопировать отрезок...</li>
<li><code>p</code>  -- Вставить после курсора, если скопирована строка, вставит следующей строкой</li>
<li><code>P</code>  -- Вставить ДО курсора, если строка в буфере, то вставит до текущей</li>
<li><code>u</code>  -- Ctrl-Z</li>
<li><code>Ctrl-r</code> -- Ctrl-y</li>
<li><code>U</code>  -- Отменит все изменения, которые вы делали в этой строке недавно</li>
<li><code>x</code>  -- удалить символ</li>
<li><code>r</code>  -- заменить символ</li>
<li><code>diw</code> -- Удалить слово под кусором</li>
</ul></li>
</ul>

<hr />

<h2>Время примеров!</h2>

<p><code>d3w</code> -- удалит 3 слова, считая от курсора
<code>3d3w</code> -- 3 раза удалит 3 слова</p>

<hr />

<h3>Visual mode</h3>

<ul>
<li><code>v</code> -- Выделяет подстроку</li>
<li><code>V</code> -- Выделяет непрерывное множество строк</li>
<li><code>Ctrl-V</code> -- Выделяет столбиком</li>
</ul>

<p>Выделить что-нибудь быстро:</p>

<ul>
<li><code>viB</code> -- Выделяет блок {}</li>
<li><code>viw</code> -- Выделяет текущее слово</li>
</ul>

<p>Вы что-то выделили, можно делать следующее</p>

<ul>
<li><code>d</code> -- Удалить</li>
<li><code>y</code> -- Копировать</li>
<li><code>&lt;</code>, <code>&gt;</code> -- сдвигать</li>
<li><code>J</code> -- Объединять в одну строку</li>
<li><code>gq</code> -- Разбивать строки на много (попробуйте написать строку, не влезающую в одну строку)</li>
<li><code>zf</code> -- (zip fold) - Cворачивает выделенный кусок. (Неважно, как вы выделяли, он свернёт строки)</li>
<li><code>:&lt;command&gt;</code> -- Выполнит команду на выделенном куске. (Он напишет некие символы, не обращайте на них внимания)
<ul>
<li>:sort -- лексикографически отсортирует строки</li>
<li>:!&lt;любая внешняя команда> -- передаст этой команде на ввод строки, вывод запишет вместо этих строк
F.e.  :!tac -- развернёт</li>
</ul></li>
</ul>

<h4>Что можно делать с zip-ами</h4>

<ul>
<li><code>zf</code> -- Свернуть</li>
<li><code>za</code> -- Изменить состояние (если вы сворачивали какой-то кусок в этом сеансе редактирования, <strong>Vim</strong> запомнит
Это и вы можете много раз сворачивать-разворачивать куски кода</li>
<li><code>zo</code> -- Развернуть</li>
<li><code>zc</code> -- Свернуть</li>
</ul>

<h2>Поиск</h2>

<p>Чтобы искать что-нибудь по всему файлу, пишите</p>

<p>В Normal mode, конечно</p>

<ul>
<li><code>/find</code> -- ищет подстроку find</li>
<li><code>#</code> -- Переходит к предыдущему вхождению слова под курсором</li>
<li><code>*</code> -- Переходит к следующему ...</li>
</ul>

<h2>Замена</h2>

<p>Большая тема, очень важная</p>

<p>Варианты:</p>

<ul>
<li><code>:s/find/replace/flags</code> -- заменит в текущей строке</li>
<li><code>&lt;Выделить строки&gt;:s/find/replace/flags</code> -- заменит в выделении</li>
<li><code>:%s/find/replace/flags</code> -- заменит во всём файле</li>
</ul>

<h3>flags</h3>

<ul>
<li><code>g</code> -- Не только первые вхождения</li>
<li><code>c</code> -- Будет некий диалог подтверждения, полезно, если надо менять не все</li>
</ul>

<h3>find</h3>

<p><strong>Vim</strong> Поддерживает регулярные выражения (строки, которым подходят сразу несколько)</p>

<p><em>Некоторые возможности</em></p>

<ul>
<li><code>.</code> -- Один любой символ</li>
<li><code>^</code> -- Начало строки</li>
<li><code>$</code> -- Конец строки</li>
<li><code>\w</code> -- буква</li>
<li><code>\W</code> -- не-буква</li>
<li><code>\s</code> -- пробельный символ (Таб или пробел)</li>
<li><code>\S</code> -- непробельный символ</li>
<li>[ad-k] -- Один символ из множества {a, d, e, f, g, i, j, k}
(можно писать знак <code>-</code> между символами, тогда в мн-во включаются все символы между ними)</li>
<li>[^ad-k] -- Один символ НЕ из множества {a, d, e, f, g, i, j, k}
(<code>^</code> в начале множества - отрицание)</li>
<li><code>*</code> -- любое количество того, что перед ней
<ul>
<li><code>.*</code> -- Любая строка</li>
<li><code>a*</code> -- Строка, состоящая из любого количества букв <code>a</code>, возможно, 0</li>
<li><code>[a-f]*</code> -- Строка, состоящая только из букв {a, b, c, d, e, f} (С повторениями, возможно не из всех)</li>
</ul></li>
<li>( ) -- Запоминает то, что внутри, и это можно использовать в замене<br>
То, что было внутри первой пары ( ), можно получить как \1<br>
Внутри второй - \2<br>
...</li>
</ul>

<h3>Примеры</h3>

<h4>Было</h4>

<p><code>abcdef</code></p>

<h4>Применили</h4>

<p><code>$:s/\([a-d]*\)/\1x\1/</code></p>

<h4>Стало</h4>

<p><code>abcdxabcdef</code></p>

<p><em>Это лишь малая часть, остальное написано в <code>man perlre</code></em></p>
